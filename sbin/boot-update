#!/usr/bin/python2

import os, sys

BLUE="[34;01m"
CYAN="[36;01m"
CYANN="[36m"
GREEN="[32;01m"
RED="[31;01m"
PURP="[35;01m"
OFF="[0m"
version="1.4"
verbose=False

# This is needed for testing from the root of the git repo - must come before funtoo imports
if os.path.isdir(".git") and os.path.basename(os.getcwd()) == "coreboot":
	sys.path = [ "python/modules" ] + sys.path 

# Import Funtoo extensions that we use:

import funtoo.boot.config
import funtoo.boot.helper
import funtoo.boot.extensions

def versinfo():
	print
	print " Copyright "+CYANN+"2010"+OFF+" Funtoo Technologies."
	print
	print """ This program is free software; you can redistribute and/or modify it under
 the terms of the GNU General Public License version 3 as published by the
 Free Software Foundation. Alternatively you may (at your option) use any
 other license that has been publicly approved for use with this program by
 Funtoo Technologies, LLC. (or its successors, if any.)
 """

def banner():
	print
	print " "+PURP+"boot-update "+OFF+CYANN+version+OFF+" /",
	print "Copyright 2010 Funtoo Technologies",
	print "(\"-v\" for license info)"
	print

def mesg(type,line):
	global verbose
	if verbose and type == "info":
		print GREEN+" *"+OFF+" "+line
	elif type == "norm":
		print GREEN+" *"+OFF+" "+line
	elif type == "boot":
		print CYAN+" >>> "+GREEN+line+OFF
	elif type == "warn":
		print RED+" *"+OFF+" "+line

def cleanup(ok,allmsgs):
	global verbose
	warnings = False

	# This is the function that prints all accumulated errors and/or warnings and exits with
	# the proper return code.

	for type, msg in allmsgs:
		if type == "warn":
			print RED+" * WARN :"+OFF+" %s" % msg
			warnings=True
		elif type == "fatal":
			print RED+" * ERROR:"+OFF+" %s" % msg
		elif (verbose and type == "info") or type == "norm":
			print GREEN+" * "+OFF+msg
	if not ok:
		print RED+" * Did not complete successfully."+OFF
		print
		sys.exit(1)
	else:
		out=GREEN+" * "+OFF+"Completed successfully"
		if warnings:
			print out+" with warnings."
		else:
			print out+"."
		print
		sys.exit(0)

def update(c,ok,allmsgs):

	# Generate warnings for any invalid config file entries...
	for invalid in c.validate():
		allmsgs.append(["warn","invalid config setting \"%s\"; ignored." % invalid])

	# Figure out what extension we should be loading...
	
	generate=c["boot/generate"]

	if generate=="":
		ok=False
		allmsgs.append(["fatal","boot/generate does not specify a valid boot loader to generate a config for."])

	if generate not in funtoo.boot.extensions.__all__:
		ok=False
		allmsgs.append(["fatal","extension for boot loader \"%s\" (specified in boot/generate) not found." % generate ])
	
	if not ok:
		cleanup(ok,allmsgs)

	# Before loading extension, we want to auto-mount boot if it isn't already mounted:
	
	imountedit = False

	if funtoo.boot.helper.fstabHasEntry("/boot"):
		if not os.path.ismount("/boot"):
			mesg("info","Mounting filesystem /boot...")
			os.system("mount /boot")
			imountedit=True
	else:
		mesg("info","No /etc/fstab entry for /boot; not mounting.")

	# Dynamically import the proper extension module (ie. grub.py, grub-legacy.py, lilo.py):

	extname="funtoo.boot.extensions.%s" % generate
	__import__(extname)
	extmodule=sys.modules[extname]

	# Create Boot Loader Extension object:
	ext=extmodule.getExtension(c)
	ext.mesg=mesg


	# Regenerate Config File:

	step, ok, msgs = ext.regenerate()
	allmsgs += msgs
	if ok:
		for bootitem in ext.bootitems:
			mesg("boot",bootitem)
		print

	# If we mounted /boot, we should unmount it:
	if imountedit:
		mesg("info","Unmounting /boot")
		os.system("umount /boot")

	cleanup(ok,allmsgs)


if len(sys.argv)>=2 and (( "-v" in sys.argv ) or ( "--version" in sys.argv )):
	versinfo()
	sys.exit(0)

if "-V" in sys.argv or ("--verbose" in sys.argv):
	verbose=True

ok=True
allmsgs=[]
cfile="/etc/boot.conf"


# Load /etc/boot.conf master configuration file:

c=funtoo.boot.config.BootConfigFile(cfile)

if not c.fileExists():
	ok=False
	allmsgs.append(["fatal","Master configuration file \"%s\" does not exist." % cfile])
	cleanup(ok,allmsgs)

if len(sys.argv)>=3 and sys.argv[1] == "--show":
	print c[sys.argv[2]]
elif len(sys.argv)>=2 and sys.argv[1] == "--showdefaults":
	for line in c.parent.dump():
		sys.stdout.write(line)
else:
	banner()
	update(c,ok,allmsgs)

